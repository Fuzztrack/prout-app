================================================================================
FLUX COMPLET DE PREMI√àRE INSCRIPTION - TOUS LES FICHIERS ET FONCTIONS
================================================================================

üìã TABLE DES MATI√àRES
1. Vue d'ensemble du flux
2. Fichiers TypeScript complets
3. Scripts SQL complets
4. Configuration Supabase

================================================================================
1. VUE D'ENSEMBLE DU FLUX
================================================================================

√âTAPE 1: WelcomeScreen (Premi√®re ouverture)
  ‚Üí Demande permissions notifications et contacts
  ‚Üí Marque @welcome_screen_seen dans AsyncStorage
  ‚Üí Redirige vers SignupScreen

√âTAPE 2: SignupScreen (Formulaire d'inscription)
  ‚Üí Utilisateur remplit: pseudo, email, t√©l√©phone (optionnel), mot de passe
  ‚Üí Validation des champs
  ‚Üí Appel supabase.auth.signUp() avec m√©tadonn√©es (pseudo, phone, expo_push_token)
  ‚Üí Trigger SQL cr√©e automatiquement le profil dans user_profiles
  ‚Üí Si email confirmation activ√©e: redirige vers LoginScreen avec message
  ‚Üí Si pas de confirmation: redirige vers home

√âTAPE 3: Confirmation email (si activ√©e)
  ‚Üí Utilisateur clique sur lien dans email
  ‚Üí Deep link proutapp://confirm-email ouvre l'app
  ‚Üí _layout.tsx g√®re le deep link et cr√©e la session
  ‚Üí Redirige vers LoginScreen

√âTAPE 4: LoginScreen (Connexion)
  ‚Üí Utilisateur entre email et mot de passe
  ‚Üí V√©rifie si email confirm√©
  ‚Üí V√©rifie si profil existe
  ‚Üí Redirige vers home si tout est OK

√âTAPE 5: index.tsx (Point d'entr√©e)
  ‚Üí V√©rifie si WelcomeScreen d√©j√† vue
  ‚Üí V√©rifie session Supabase
  ‚Üí V√©rifie profil utilisateur
  ‚Üí Redirige vers l'√©cran appropri√©

================================================================================
2. FICHIERS TYPESCRIPT COMPLETS
================================================================================

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: app/index.tsx
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

// app/index.tsx - Page de d√©marrage qui v√©rifie la session et le profil
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useRouter } from 'expo-router';
import { useEffect, useRef } from 'react';
import { Image, StyleSheet, View } from 'react-native';
import { supabase } from '../lib/supabase';

export default function SplashScreen() {
  const router = useRouter();
  const hasNavigated = useRef(false);

  useEffect(() => {
    let timeoutId: NodeJS.Timeout | undefined;
    let isChecking = false;

    const checkUserProfile = async () => {
      if (isChecking || hasNavigated.current) return;
      isChecking = true;

      try {
        // V√©rifier si c'est la premi√®re installation (WelcomeScreen pas encore vue)
        const welcomeSeen = await AsyncStorage.getItem('@welcome_screen_seen');
        
        if (!welcomeSeen) {
          // Premi√®re installation : rediriger vers WelcomeScreen
          console.log('‚ÑπÔ∏è Premi√®re installation, redirection vers WelcomeScreen');
          if (!hasNavigated.current) {
            hasNavigated.current = true;
            router.replace('/WelcomeScreen');
          }
          return;
        }

        // Essayer de restaurer la session depuis AsyncStorage si Supabase ne l'a pas fait automatiquement
        try {
          const allKeys = await AsyncStorage.getAllKeys();
          const supabaseKeys = allKeys.filter(key => key.startsWith('sb-'));
          
          for (const key of supabaseKeys) {
            const storedSession = await AsyncStorage.getItem(key);
            if (storedSession) {
              try {
                const sessionObj = JSON.parse(storedSession);
                if (sessionObj?.access_token && sessionObj?.refresh_token) {
                  console.log(`üîÑ Tentative de restauration de session depuis AsyncStorage (cl√©: ${key})...`);
                  const { data: { session }, error: setSessionError } = await supabase.auth.setSession({
                    access_token: sessionObj.access_token,
                    refresh_token: sessionObj.refresh_token,
                  });
                  
                  if (!setSessionError && session?.user) {
                    console.log('‚úÖ Session restaur√©e manuellement depuis AsyncStorage');
                    break;
                  }
                }
              } catch (parseError) {
                continue;
              }
            }
          }
        } catch (storageError) {
          console.log('‚ö†Ô∏è Erreur lors de la lecture d\'AsyncStorage:', storageError);
        }

        // Attendre un peu pour que Supabase restaure la session
        await new Promise(resolve => setTimeout(resolve, 500));

        // V√©rifier la session
        const { data: { session }, error: sessionError } = await supabase.auth.getSession();
        
        console.log('üîç V√©rification session:', { 
          hasSession: !!session?.user, 
          userId: session?.user?.id,
          error: sessionError?.message 
        });
        
        if (session?.user) {
          // V√©rifier si l'email est confirm√©
          if (!session.user.email_confirmed_at) {
            console.log('‚ö†Ô∏è Email non confirm√©, redirection vers LoginScreen');
            if (!hasNavigated.current) {
              hasNavigated.current = true;
              router.replace('/LoginScreen');
            }
            return;
          }
          
          // Session active : v√©rifier si le profil existe
          const { data: profile, error: profileError } = await supabase
            .from('user_profiles')
            .select('*')
            .eq('id', session.user.id)
            .single();

          if (profileError || !profile) {
            // Pas de profil : rediriger vers l'inscription pour compl√©ter
            console.log('‚ÑπÔ∏è Session active mais pas de profil, redirection vers SignupScreen');
            if (!hasNavigated.current) {
              hasNavigated.current = true;
              router.replace('/SignupScreen');
            }
            return;
          }

          // Profil existe, session active et email confirm√© : rediriger vers l'accueil
          console.log('‚úÖ Session, profil et email confirm√© trouv√©s, redirection vers l\'accueil');
          if (!hasNavigated.current) {
            hasNavigated.current = true;
            router.replace('/home');
          }
          return;
        }

        // Pas de session : rediriger vers l'inscription
        console.log('‚ÑπÔ∏è Aucune session trouv√©e, redirection vers SignupScreen');
        if (!hasNavigated.current) {
          hasNavigated.current = true;
          router.replace('/SignupScreen');
        }
      } catch (error) {
        console.error('‚ùå Erreur lors de la v√©rification:', error);
        if (!hasNavigated.current) {
          hasNavigated.current = true;
          router.replace('/SignupScreen');
        }
      } finally {
        isChecking = false;
      }
    };

    // √âcouter les changements d'authentification
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      console.log(`üîî √âv√©nement auth: ${event}`, { hasSession: !!session?.user });
      
      if (hasNavigated.current) return;

      if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || event === 'INITIAL_SESSION') {
        if (session?.user) {
          console.log(`‚úÖ √âv√©nement auth: ${event}, session restaur√©e pour ${session.user.id}`);
          
          if (!session.user.email_confirmed_at && event === 'SIGNED_IN') {
            console.log('‚ö†Ô∏è Email non confirm√©, redirection vers LoginScreen');
            if (!hasNavigated.current) {
              hasNavigated.current = true;
              router.replace('/LoginScreen');
            }
            return;
          }
          
          (async () => {
            try {
              const { data: profile, error: profileError } = await supabase
                .from('user_profiles')
                .select('*')
                .eq('id', session.user.id)
                .single();
              
              if (!hasNavigated.current) {
                if (profileError || !profile) {
                  console.log('‚ÑπÔ∏è Profil non trouv√©, redirection vers SignupScreen');
                  hasNavigated.current = true;
                  router.replace('/SignupScreen');
                } else {
                  if (!session.user.email_confirmed_at) {
                    console.log('‚ö†Ô∏è Email non confirm√©, redirection vers LoginScreen');
                    hasNavigated.current = true;
                    router.replace('/LoginScreen');
                  } else {
                    console.log('‚úÖ Profil trouv√© et email confirm√©, redirection vers l\'accueil');
                    hasNavigated.current = true;
                    router.replace('/home');
                  }
                }
              }
            } catch (err: any) {
              console.error('Erreur lors de la v√©rification du profil:', err);
              if (!hasNavigated.current) {
                hasNavigated.current = true;
                router.replace('/SignupScreen');
              }
            }
          })();
        }
      } else if (event === 'SIGNED_OUT') {
        if (!hasNavigated.current) {
          console.log('‚ÑπÔ∏è Utilisateur d√©connect√©, redirection vers SignupScreen');
          hasNavigated.current = true;
          router.replace('/SignupScreen');
        }
      }
    });

    checkUserProfile();

    return () => {
      subscription.unsubscribe();
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [router]);

  return (
    <View style={styles.container}>
      <Image 
        source={require('../assets/images/prout-meme.png')} 
        style={styles.headerImage}
        resizeMode="contain"
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#ebb89b',
  },
  headerImage: {
    width: 280,
    height: 210,
  },
});

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: app/WelcomeScreen.tsx
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

// app/WelcomeScreen.tsx
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Contacts from 'expo-contacts';
import * as Notifications from 'expo-notifications';
import { useRouter } from 'expo-router';
import { useState } from 'react';
import Constants from 'expo-constants';
import { Alert, Image, Platform, StyleSheet, Text, View } from 'react-native';
import { CustomButton } from '../components/CustomButton';
import { ensureAndroidNotificationChannel } from '../lib/notifications';

export default function WelcomeScreen() {
  const router = useRouter();
  const [loading, setLoading] = useState(false);

  const handleNext = async () => {
    setLoading(true);

    try {
      // 1. Demander la permission de notifications
      if (Platform.OS !== 'web' && Constants.isDevice && Constants.executionEnvironment !== 'storeClient') {
        try {
          console.log('üì± Demande de permission de notifications...');
          const { status: existingStatus } = await Notifications.getPermissionsAsync();
          
          let finalStatus = existingStatus;
          
          if (existingStatus !== 'granted') {
            const { status } = await Notifications.requestPermissionsAsync();
            finalStatus = status;
            console.log('üì± Permission apr√®s demande:', finalStatus);
            
            if (finalStatus === 'denied') {
              console.warn('‚ö†Ô∏è Permission de notifications refus√©e');
              Alert.alert(
                'Permission refus√©e',
                'Les notifications push n√©cessitent la permission de notifications. Vous pourrez l\'activer plus tard dans les param√®tres.'
              );
            } else if (finalStatus === 'granted') {
              console.log('‚úÖ Permission de notifications accord√©e');
              try {
                await ensureAndroidNotificationChannel();
                await Notifications.getExpoPushTokenAsync({
                  projectId: 'f2545544-14d4-4739-96a1-1fb75515e1e9',
                });
              } catch (tokenError) {
                console.warn('‚ö†Ô∏è Erreur lors de l\'obtention du token:', tokenError);
              }
            }
          } else {
            console.log('‚úÖ Permission de notifications d√©j√† accord√©e');
          }
        } catch (error) {
          console.error('‚ùå Erreur lors de la demande de permission de notifications:', error);
        }
      }

      // 2. Demander la permission de contacts
      if (Platform.OS === 'android' || Platform.OS === 'ios') {
        try {
          console.log('üì± Demande de permission de contacts...');
          const { status } = await Contacts.requestPermissionsAsync();
          console.log('üì± Statut de permission de contacts apr√®s demande:', status);
          
          if (status === 'denied') {
            Alert.alert(
              'Permission requise',
              'L\'acc√®s aux contacts est n√©cessaire pour que l\'application fonctionne. Vous pourrez l\'activer plus tard dans les param√®tres.'
            );
          } else if (status === 'granted') {
            console.log('‚úÖ Permission de contacts accord√©e');
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Erreur lors de la demande de permission de contacts:', error);
        }
      }

      // 3. Marquer que l'introduction a √©t√© vue
      await AsyncStorage.setItem('@welcome_screen_seen', 'true');

      // 4. Rediriger vers le flux normal
      router.replace('/SignupScreen');
    } catch (error) {
      console.error('‚ùå Erreur lors de la configuration:', error);
      Alert.alert('Erreur', 'Une erreur est survenue lors de la configuration');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Image 
          source={require('../assets/images/prout-meme.png')} 
          style={styles.headerImage}
          resizeMode="contain"
        />
      </View>
      
      <View style={styles.content}>
        <Text style={styles.title}>Plaisir d'offrir, joie de recevoir !</Text>
        
        <Text style={styles.message}>
          Prout est une application de notification, acceptez les pour jouer le jeu ;)
        </Text>
        
        <Text style={styles.message}>
          avec l'acc√®s aux contacts vous trouverez plus d'amis avec qui √©changer.
        </Text>
        
        <CustomButton
          title="Suivant"
          onPress={handleNext}
          textColor="#604a3e"
          disabled={loading}
        />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    paddingTop: 0,
    backgroundColor: '#ebb89b',
  },
  header: {
    alignItems: 'center',
    marginBottom: 0,
    marginTop: 20,
  },
  headerImage: {
    width: 280,
    height: 210,
    marginBottom: 2,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    paddingHorizontal: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#604a3e',
    textAlign: 'center',
    marginBottom: 20,
  },
  message: {
    fontSize: 16,
    color: '#604a3e',
    textAlign: 'center',
    marginBottom: 20,
    lineHeight: 24,
  },
});

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: app/SignupScreen.tsx
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

// app/SignupScreen.tsx
import { Ionicons } from '@expo/vector-icons';
import Constants from 'expo-constants';
import * as Notifications from 'expo-notifications';
import { useRouter } from 'expo-router';
import { useEffect, useState } from 'react';
import { Alert, Image, KeyboardAvoidingView, Platform, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { CustomButton } from '../components/CustomButton';
import { normalizePhone } from '../lib/normalizePhone';
import { ensureAndroidNotificationChannel } from '../lib/notifications';
import { getRedirectUrl, supabase } from '../lib/supabase';

export default function SignupScreen() {
  const router = useRouter();

  const [pseudo, setPseudo] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);

  // V√©rifier si l'utilisateur est d√©j√† connect√© au d√©marrage
  useEffect(() => {
    const checkSession = async () => {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (session?.user) {
          const { data: profile } = await supabase
            .from('user_profiles')
            .select('*')
            .eq('id', session.user.id)
            .single();

          if (profile) {
            router.replace('/home');
          }
        }
      } catch (error) {
        console.error('Erreur lors de la v√©rification de la session:', error);
      }
    };

    checkSession();
  }, [router]);

  // Fonction pour enregistrer le token Expo Push
  const registerForPushNotificationsAsync = async (): Promise<string | null> => {
    let token: string | null = null;
    
    if (Platform.OS === 'web') {
      return null;
    }

    if (Constants.isDevice === false) {
      return null;
    }

    if (Constants.executionEnvironment === 'storeClient') {
      return null;
    }

    try {
      const { status: existingStatus } = await Notifications.getPermissionsAsync();
      let finalStatus = existingStatus;
      
      if (existingStatus !== 'granted') {
        const { status } = await Notifications.requestPermissionsAsync();
        finalStatus = status;
      }
      
      if (finalStatus !== 'granted') {
        return null;
      }

      await ensureAndroidNotificationChannel();
      const tokenData = await Notifications.getExpoPushTokenAsync({
        projectId: 'f2545544-14d4-4739-96a1-1fb75515e1e9',
      });
      token = tokenData.data;
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration du token:', error);
      return null;
    }
    return token;
  };

  const handleSignup = async () => {
    // --- 1. VALIDATIONS ---
    const trimmedPseudo = pseudo.trim();
    const trimmedEmail = email.trim();
    const trimmedPassword = password.trim();
    const trimmedPhone = phone.trim();

    if (!trimmedPseudo) return Alert.alert('Erreur', 'Veuillez entrer un pseudo');
    if (!trimmedEmail) return Alert.alert('Erreur', 'Veuillez entrer un email');
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(trimmedEmail)) return Alert.alert('Erreur', 'Email invalide');
    if (trimmedEmail.toLowerCase().includes('@temp.proutapp.local')) {
      return Alert.alert('Erreur', 'Email temporaire non accept√©');
    }
    
    if (!trimmedPassword || trimmedPassword.length < 6) {
      return Alert.alert('Erreur', 'Le mot de passe doit faire 6 caract√®res minimum');
    }

    setLoading(true);
    try {
      // --- 2. PR√âPARATION ---
      const emailToUse = trimmedEmail.toLowerCase();
      
      // Normalisation du t√©l√©phone
      let normalizedPhone: string | null = null;
      if (trimmedPhone) {
        normalizedPhone = normalizePhone(trimmedPhone);
        if (!normalizedPhone) {
          setLoading(false);
          return Alert.alert('Erreur', 'Num√©ro de t√©l√©phone invalide');
        }
      }

      // R√©cup√©ration du token de notification (si dispo)
      let expoPushToken = null;
      try {
        expoPushToken = await registerForPushNotificationsAsync();
      } catch (e) {
        console.log('Push token non dispo (simulateur ou refus), continuons...');
      }

      // --- 3. INSCRIPTION (Le Trigger SQL fera le reste !) ---
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email: emailToUse,
        password: trimmedPassword,
        options: {
          emailRedirectTo: getRedirectUrl(),
          // üî• C'est ICI que la magie op√®re : ces donn√©es sont envoy√©es au Trigger SQL
          data: {
            pseudo: trimmedPseudo,
            phone: normalizedPhone || null,
            expo_push_token: expoPushToken || null, 
          },
        },
      });

      if (authError) throw authError;

      // --- 4. GESTION DE LA SUITE ---
      
      // Si pas de session, c'est que l'email confirmation est activ√©e
      if (authData.user && !authData.session) {
        Alert.alert(
          'V√©rifiez vos emails',
          `Un lien de confirmation a √©t√© envoy√© √† ${emailToUse}.\n\nVeuillez cliquer dessus pour activer votre compte.`,
          [{ 
            text: 'Compris', 
            onPress: () => router.replace('/LoginScreen') 
          }]
        );
      } 
      // Si session pr√©sente (cas rare ou email confirm d√©sactiv√©), on entre direct
      else if (authData.session) {
        console.log('‚úÖ Session active imm√©diate, redirection home');
        router.replace('/home');
      }

    } catch (error: any) {
      console.error('Erreur inscription:', error);
      // Gestion sp√©cifique du pseudo d√©j√† pris
      if (error.message?.includes('unique_pseudo') || error.code === '23505' || error.message?.includes('d√©j√† utilis√©')) {
        Alert.alert('Oups', 'Ce pseudo est d√©j√† utilis√©, veuillez en choisir un autre.');
      } else {
        Alert.alert('Erreur', error.message || "Une erreur est survenue lors de l'inscription");
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
      <View style={styles.header}>
        <Image 
          source={require('../assets/images/prout-meme.png')} 
          style={styles.headerImage}
          resizeMode="contain"
        />
      </View>
      <Text style={styles.title}>Inscription</Text>
      <Text style={styles.fieldLabel}>Pseudo *</Text>
      <TextInput
        placeholder="Entrez ici un pseudo"
        value={pseudo}
        onChangeText={setPseudo}
        style={styles.input}
        autoCapitalize="none"
      />
      <Text style={styles.fieldLabel}>Email *</Text>
      <TextInput
        placeholder="Entrez votre email (obligatoire)"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
        style={styles.input}
      />
      <Text style={styles.fieldLabel}>Num√©ro de t√©l√©phone</Text>
      <TextInput
        placeholder="Entrez ici votre num√©ro de t√©l√©phone"
        value={phone}
        onChangeText={setPhone}
        keyboardType="phone-pad"
        style={styles.input}
      />
        <Text style={styles.fieldLabel}>Mot de passe *</Text>
      <View style={styles.passwordContainer}>
        <TextInput
          placeholder="Entrez un mot de passe (min. 6 caract√®res)"
          value={password}
          onChangeText={setPassword}
          secureTextEntry={!showPassword}
          style={styles.passwordInput}
          placeholderTextColor="#999"
        />
        <TouchableOpacity
          onPress={() => setShowPassword(!showPassword)}
          style={styles.eyeIcon}
        >
          <Ionicons
            name={showPassword ? 'eye-off' : 'eye'}
            size={24}
            color="#604a3e"
          />
        </TouchableOpacity>
      </View>
      <CustomButton 
        title={loading ? 'Chargement...' : "S'inscrire"} 
        onPress={handleSignup} 
        disabled={loading} 
        loading={loading} 
        textColor="#604a3e" 
      />
      <CustomButton 
        title="D√©j√† un compte ? Se connecter" 
        onPress={() => router.replace('/LoginScreen')} 
        textColor="#604a3e"
        small
      />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#ebb89b' },
  scrollContent: { flexGrow: 1, padding: 20, paddingTop: 20, paddingBottom: 40 },
  header: { alignItems: 'center', marginBottom: 5 },
  headerImage: { width: 280, height: 210, marginBottom: 2 },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20, textAlign: 'center', color: '#604a3e' },
  fieldLabel: { fontSize: 16, fontWeight: '600', color: '#604a3e', marginBottom: 8, textAlign: 'left' },
  input: { backgroundColor: '#fff', borderWidth: 1, borderColor: '#ccc', padding: 10, marginBottom: 15, borderRadius: 5, color: '#000' },
  passwordContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
    marginBottom: 15,
  },
  passwordInput: {
    flex: 1,
    padding: 10,
    color: '#000',
  },
  eyeIcon: {
    padding: 10,
  },
});

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: app/LoginScreen.tsx
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

// app/LoginScreen.tsx
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useEffect, useState } from 'react';
import { Alert, Image, KeyboardAvoidingView, Platform, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { CustomButton } from '../components/CustomButton';
import { supabase } from '../lib/supabase';

export default function LoginScreen() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);

  // V√©rifier si une session existe d√©j√† au chargement
  useEffect(() => {
    const checkSession = async () => {
      await new Promise(resolve => setTimeout(resolve, 500));

      const { data: { session } } = await supabase.auth.getSession();
      
      if (session?.user) {
        const { data: profile } = await supabase
          .from('user_profiles')
          .select('*')
          .eq('id', session.user.id)
          .single();

        if (profile) {
          console.log('‚úÖ Session trouv√©e dans LoginScreen, redirection vers home');
          router.replace('/home');
        }
      }
    };

    checkSession();
  }, [router]);

  const handleLogin = async () => {
    if (!email || !password) {
      Alert.alert('Erreur', 'Veuillez remplir tous les champs');
      return;
    }

    setLoading(true);
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) {
        if (error.message?.includes('email not confirmed') || error.message?.includes('Email not confirmed')) {
          Alert.alert(
            'Email non confirm√©',
            'Votre email n\'a pas encore √©t√© confirm√©.\n\nVeuillez v√©rifier votre bo√Æte de r√©ception et cliquer sur le lien de confirmation dans l\'email que nous vous avons envoy√©.\n\nSi vous n\'avez pas re√ßu l\'email, v√©rifiez vos spams ou contactez le support.',
            [
              {
                text: 'Renvoyer l\'email',
                onPress: async () => {
                  try {
                    const { error: resendError } = await supabase.auth.resend({
                      type: 'signup',
                      email: email.trim().toLowerCase(),
                    });
                    
                    if (resendError) {
                      Alert.alert('Erreur', 'Impossible de renvoyer l\'email. Veuillez r√©essayer plus tard.');
                    } else {
                      Alert.alert('Email envoy√©', 'Un nouvel email de confirmation a √©t√© envoy√©.');
                    }
                  } catch (err) {
                    console.error('Erreur lors du renvoi de l\'email:', err);
                    Alert.alert('Erreur', 'Impossible de renvoyer l\'email.');
                  }
                },
              },
              {
                text: 'OK',
                style: 'cancel',
              },
            ]
          );
        } else {
          Alert.alert('Erreur de connexion', error.message);
        }
        return;
      }

      if (data.user && data.session) {
        console.log('‚úÖ Session cr√©√©e lors de la connexion:', data.session.user.id);
        
        if (!data.user.email_confirmed_at) {
          Alert.alert(
            'Email non confirm√©',
            'Votre email n\'a pas encore √©t√© confirm√©.\n\nVeuillez v√©rifier votre bo√Æte de r√©ception et cliquer sur le lien de confirmation.',
            [
              {
                text: 'Renvoyer l\'email',
                onPress: async () => {
                  try {
                    const { error: resendError } = await supabase.auth.resend({
                      type: 'signup',
                      email: data.user.email!,
                    });
                    
                    if (resendError) {
                      Alert.alert('Erreur', 'Impossible de renvoyer l\'email.');
                    } else {
                      Alert.alert('Email envoy√©', 'Un nouvel email de confirmation a √©t√© envoy√©.');
                    }
                  } catch (err) {
                    console.error('Erreur lors du renvoi de l\'email:', err);
                  }
                },
              },
              {
                text: 'OK',
                style: 'cancel',
              },
            ]
          );
          return;
        }
        
        const { data: profile, error: profileError } = await supabase
          .from('user_profiles')
          .select('*')
          .eq('id', data.user.id)
          .single();

        if (profileError || !profile) {
          Alert.alert('Information', 'Veuillez compl√©ter votre profil');
          router.replace('/SignupScreen');
          return;
        }

        router.replace('/home');
      }
    } catch (err) {
      console.error('Erreur lors de la connexion:', err);
      Alert.alert('Erreur', 'Une erreur est survenue lors de la connexion');
    } finally {
      setLoading(false);
    }
  };

  const handleResetPassword = async () => {
    const trimmedEmail = email.trim().toLowerCase();

    if (!trimmedEmail) {
      Alert.alert('Erreur', 'Veuillez entrer votre email pour r√©initialiser le mot de passe');
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(trimmedEmail)) {
      Alert.alert('Erreur', 'Veuillez entrer un email valide');
      return;
    }

    if (trimmedEmail.includes('@temp.proutapp.local')) {
      Alert.alert(
        'Erreur',
        'Impossible de r√©initialiser le mot de passe avec un email temporaire.\n\nVeuillez contacter le support ou utiliser un email r√©el.'
      );
      return;
    }

    try {
      setLoading(true);
      const { error } = await supabase.auth.resetPasswordForEmail(trimmedEmail, {
        redirectTo: 'proutapp://reset-password',
      });

      if (error) {
        if (error.message?.includes('not found') || error.message?.includes('does not exist')) {
          Alert.alert(
            'Email non trouv√©',
            'Aucun compte n\'est associ√© √† cet email. V√©rifiez votre adresse email.'
          );
        } else if (error.message?.includes('rate limit') || error.message?.includes('too many')) {
          Alert.alert(
            'Trop de tentatives',
            'Vous avez fait trop de demandes. Veuillez patienter quelques minutes avant de r√©essayer.'
          );
        } else {
          Alert.alert('Erreur', error.message || 'Impossible d\'envoyer l\'email de r√©initialisation');
        }
        return;
      }

      Alert.alert(
        'Email envoy√©',
        'Un email de r√©initialisation a √©t√© envoy√© √† votre adresse.\n\nV√©rifiez votre bo√Æte de r√©ception (et vos spams) et suivez les instructions pour r√©initialiser votre mot de passe.'
      );
    } catch (err) {
      console.error('Erreur lors de la r√©initialisation:', err);
      Alert.alert('Erreur', 'Une erreur est survenue lors de l\'envoi de l\'email');
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
    >
      <ScrollView 
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.header}>
          <Image 
            source={require('../assets/images/prout-meme.png')} 
            style={styles.headerImage}
            resizeMode="contain"
          />
        </View>
        <Text style={styles.title}>Connexion</Text>
        <Text style={styles.fieldLabel}>Email</Text>
        <TextInput
          placeholder="Entrez votre email"
          value={email}
          onChangeText={setEmail}
          keyboardType="email-address"
          autoCapitalize="none"
          style={styles.input}
        />
        <Text style={styles.fieldLabel}>Mot de passe</Text>
        <View style={styles.passwordContainer}>
          <TextInput
            placeholder="Entrez votre mot de passe"
            value={password}
            onChangeText={setPassword}
            secureTextEntry={!showPassword}
            style={styles.passwordInput}
            placeholderTextColor="#999"
          />
          <TouchableOpacity
            onPress={() => setShowPassword(!showPassword)}
            style={styles.eyeIcon}
          >
            <Ionicons
              name={showPassword ? 'eye-off' : 'eye'}
              size={24}
              color="#604a3e"
            />
          </TouchableOpacity>
        </View>
        <CustomButton 
          title={loading ? 'Connexion...' : 'Se connecter'} 
          onPress={handleLogin} 
          disabled={loading} 
          loading={loading} 
          textColor="#604a3e" 
        />
        <CustomButton 
          title="Mot de passe oubli√© ?" 
          onPress={handleResetPassword} 
          textColor="#604a3e"
          small
        />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#ebb89b' },
  scrollContent: { flexGrow: 1, padding: 20, paddingTop: 20, paddingBottom: 40 },
  header: { alignItems: 'center', marginBottom: 5 },
  headerImage: { width: 280, height: 210, marginBottom: 2 },
  title: { fontSize: 24, fontWeight: 'bold', marginBottom: 20, textAlign: 'center', color: '#604a3e' },
  fieldLabel: { fontSize: 16, fontWeight: '600', color: '#604a3e', marginBottom: 8, textAlign: 'left' },
  input: { backgroundColor: '#fff', borderWidth: 1, borderColor: '#ccc', padding: 10, marginBottom: 15, borderRadius: 5, color: '#000' },
  passwordContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
    marginBottom: 15,
  },
  passwordInput: {
    flex: 1,
    padding: 10,
    color: '#000',
  },
  eyeIcon: {
    padding: 10,
  },
});

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: lib/supabase.ts
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from "@supabase/supabase-js";
import { Platform } from 'react-native';

export const supabase = createClient(
  'https://utfwujyymaikraaigvuv.supabase.co',
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV0Znd1anl5bWFpa3JhYWlndnV2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxODkwNzAsImV4cCI6MjA3ODc2NTA3MH0.d6MLGOsvTlxJDARH64D1u4kJHxKAlfX1FLegrWVE-Is",
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: Platform.OS === 'web',
      storage: AsyncStorage,
    },
  }
);

export const getRedirectUrl = () => {
  if (Platform.OS === 'web' && typeof window !== 'undefined') {
    return window.location.origin;
  }
  return 'proutapp://confirm-email';
};

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: lib/normalizePhone.ts
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

export function normalizePhone(number: string): string {
  if (!number) return "";
  
  let cleaned = number
    .replace(/\s+/g, "")
    .replace(/-/g, "")
    .replace(/\./g, "")
    .replace(/\(/g, "")
    .replace(/\)/g, "")
    .trim();
  
  if (cleaned.startsWith("+33")) {
    cleaned = "0" + cleaned.substring(3);
  }
  else if (cleaned.startsWith("00")) {
    cleaned = "+" + cleaned.substring(2);
    if (cleaned.startsWith("+33")) {
      cleaned = "0" + cleaned.substring(3);
    }
  }
  
  return cleaned;
}

export function comparePhones(phone1: string, phone2: string): boolean {
  const normalized1 = normalizePhone(phone1);
  const normalized2 = normalizePhone(phone2);
  
  if (normalized1 === normalized2) return true;
  
  const last9_1 = normalized1.slice(-9);
  const last9_2 = normalized2.slice(-9);
  if (last9_1 === last9_2 && last9_1.length === 9 && /^\d+$/.test(last9_1)) {
    return true;
  }
  
  return false;
}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: components/CustomButton.tsx
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

import { ActivityIndicator, Image, ImageSourcePropType, StyleSheet, Text, TouchableOpacity } from 'react-native';

interface CustomButtonProps {
  title: string;
  onPress: () => void;
  disabled?: boolean;
  loading?: boolean;
  color?: string;
  textColor?: string;
  small?: boolean;
  iconSource?: ImageSourcePropType;
  iconOnly?: boolean;
}

export function CustomButton({ title, onPress, disabled, loading, color, textColor: customTextColor, small, iconSource, iconOnly }: CustomButtonProps) {
  const buttonColor = color || '#adb9b3';
  const textColor = customTextColor || '#ebb89b';

  return (
    <TouchableOpacity
      style={[
        styles.button,
        small && styles.buttonSmall,
        iconOnly && styles.buttonIconOnly,
        { backgroundColor: buttonColor },
        (disabled || loading) && styles.buttonDisabled,
      ]}
      onPress={onPress}
      disabled={disabled || loading}
      activeOpacity={0.7}
    >
      {loading ? (
        <ActivityIndicator color={textColor} size={small ? 'small' : 'large'} />
      ) : (
        <>
          {iconSource && (
            <Image 
              source={iconSource} 
              style={[styles.buttonIcon, small && styles.buttonIconSmall, iconOnly && styles.buttonIconOnlySize]} 
              resizeMode="contain"
            />
          )}
          {!iconOnly && (
            <Text style={[styles.buttonText, small && styles.buttonTextSmall, { color: textColor }]}>{title}</Text>
          )}
        </>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  button: {
    backgroundColor: '#adb9b3',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 44,
    marginBottom: 10,
  },
  buttonDisabled: {
    opacity: 0.5,
  },
  buttonText: {
    color: '#ebb89b',
    fontSize: 16,
    fontWeight: '600',
  },
  buttonSmall: {
    paddingVertical: 6,
    paddingHorizontal: 12,
    minHeight: 32,
    marginBottom: 5,
  },
  buttonTextSmall: {
    fontSize: 14,
  },
  buttonIconOnly: {
    padding: 8,
    minWidth: 40,
    minHeight: 40,
    borderRadius: 20,
    aspectRatio: 1,
  },
  buttonIcon: {
    width: 20,
    height: 20,
    marginRight: 8,
  },
  buttonIconSmall: {
    width: 16,
    height: 16,
    marginRight: 6,
  },
  buttonIconOnlySize: {
    width: 24,
    height: 24,
    marginRight: 0,
  },
});

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: app/_layout.tsx (Fonction handleDeepLink uniquement)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

// NOTE: Ce fichier contient aussi d'autres √©l√©ments (Stack, etc.)
// Seule la fonction handleDeepLink est montr√©e ici pour le flux d'inscription

const handleDeepLink = async (url: string) => {
  try {
    console.log('üîç Traitement du deep link complet:', url);

    // V√©rifier si c'est une URL OAuth avec access_token dans le hash
    const hasOAuthTokens = url.includes('#access_token=') || 
                          (url.includes('access_token=') && (url.includes('supabase.co') || url.includes('confirm-email')));
    
    if (hasOAuthTokens) {
      console.log('‚úÖ URL OAuth avec tokens d√©tect√©e');
      
      const hashMatch = url.match(/#(.+)/);
      if (hashMatch) {
        const hashParams = new URLSearchParams(hashMatch[1]);
        const accessToken = hashParams.get('access_token');
        const refreshToken = hashParams.get('refresh_token');
        const type = hashParams.get('type');
        
        if (accessToken && refreshToken) {
          try {
            const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
              access_token: accessToken,
              refresh_token: refreshToken,
            });
            
            if (sessionError) {
              console.error('‚ùå Erreur lors de la cr√©ation de la session OAuth:', sessionError);
              Alert.alert(
                'Erreur',
                'Impossible de confirmer votre email. Le lien peut √™tre expir√© ou invalide.',
                [{ text: 'OK', onPress: () => router.replace('/LoginScreen') }]
              );
              return;
            }
            
            if (sessionData?.session?.user) {
              const user = sessionData.session.user;
              console.log('‚úÖ Session OAuth cr√©√©e avec succ√®s pour:', user.id);
              
              if (user.email_confirmed_at) {
                console.log('‚úÖ Email confirm√© avec succ√®s via OAuth');
                Alert.alert(
                  'Email confirm√©',
                  'Votre email a √©t√© confirm√© avec succ√®s ! Vous pouvez maintenant vous connecter.',
                  [{ text: 'OK', onPress: () => router.replace('/LoginScreen') }]
                );
              } else {
                Alert.alert(
                  'Confirmation en cours',
                  'Votre email est en cours de confirmation. Vous pouvez vous connecter.',
                  [{ text: 'OK', onPress: () => router.replace('/LoginScreen') }]
                );
              }
              return;
            }
          } catch (oauthError) {
            console.error('‚ùå Erreur lors du traitement OAuth:', oauthError);
          }
        }
      }
    }

    // V√©rifier si c'est une URL Supabase de confirmation
    const isSupabaseVerifyUrl = url.includes('/auth/v1/verify') || 
                              url.includes('confirmation_token') || 
                              url.includes('type=signup') ||
                              url.includes('token_hash=') ||
                              url.includes('token=');

    if (isSupabaseVerifyUrl) {
      console.log('‚úÖ URL de confirmation Supabase d√©tect√©e');
      
      const parsedUrl = Linking.parse(url);
      const { queryParams } = parsedUrl;
      
      let token: string | null = null;
      let tokenType: 'signup' | 'email' | null = null;

      if (queryParams?.token) {
        token = queryParams.token as string;
        tokenType = (queryParams.type as 'signup' | 'email') || 'signup';
      } else if (queryParams?.token_hash) {
        token = queryParams.token_hash as string;
        tokenType = (queryParams.type as 'signup' | 'email') || 'signup';
      } else if (queryParams?.confirmation_token) {
        token = queryParams.confirmation_token as string;
        tokenType = 'signup';
      }

      if (!token) {
        const tokenMatch = url.match(/[?&](?:token|token_hash|confirmation_token)=([^&]+)/);
        if (tokenMatch) {
          token = decodeURIComponent(tokenMatch[1]);
          const typeMatch = url.match(/[?&]type=([^&]+)/);
          tokenType = (typeMatch ? decodeURIComponent(typeMatch[1]) : 'signup') as 'signup' | 'email';
        }
      }

      if (token && tokenType) {
        try {
          let verifyResult = await supabase.auth.verifyOtp({
            token_hash: token,
            type: tokenType,
          });

          if (verifyResult.error) {
            console.error('‚ùå Erreur lors de la v√©rification OTP:', verifyResult.error);
          } else if (verifyResult.data?.user) {
            console.log('‚úÖ Email confirm√© avec succ√®s via verifyOtp');
            Alert.alert(
              'Email confirm√©',
              'Votre email a √©t√© confirm√© avec succ√®s ! Vous pouvez maintenant vous connecter.',
              [{ text: 'OK', onPress: () => router.replace('/LoginScreen') }]
            );
            return;
          }
        } catch (otpError) {
          console.error('‚ùå Erreur lors de verifyOtp:', otpError);
        }
      }

      // V√©rifier la session
      const { data: { session }, error: sessionError } = await supabase.auth.getSession();
      
      if (sessionError) {
        Alert.alert('Erreur', 'Impossible de confirmer votre email.');
        router.replace('/LoginScreen');
        return;
      }

      if (session?.user?.email_confirmed_at) {
        Alert.alert(
          'Email confirm√©',
          'Votre email a √©t√© confirm√© avec succ√®s ! Vous pouvez maintenant vous connecter.',
          [{ text: 'OK', onPress: () => router.replace('/LoginScreen') }]
        );
      } else {
        Alert.alert(
          'Confirmation en cours',
          'Votre email est en cours de confirmation. Vous pouvez vous connecter.',
          [{ text: 'OK', onPress: () => router.replace('/LoginScreen') }]
        );
      }
      return;
    }

    console.log('‚ÑπÔ∏è Deep link non reconnu, ignor√©');
  } catch (error) {
    console.error('‚ùå Erreur lors du traitement du deep link:', error);
    Alert.alert('Erreur', 'Une erreur est survenue lors du traitement du lien.');
    router.replace('/LoginScreen');
  }
};

================================================================================
3. SCRIPTS SQL COMPLETS
================================================================================

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
FICHIER: supabase_trigger_create_profile_CORRIGE.sql
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

-- ============================================================
-- üßπ 1. NETTOYAGE
-- ============================================================

DROP FUNCTION IF EXISTS create_user_profile(UUID, TEXT, TEXT, TEXT);
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user();

-- ============================================================
-- üöÄ 2. CR√âATION DU SYST√àME AUTOMATIQUE (TRIGGER)
-- ============================================================

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
LANGUAGE plpgsql
AS $$
DECLARE
  v_pseudo TEXT;
  v_phone TEXT;
  v_expo_push_token TEXT;
BEGIN
  -- Extraire les m√©tadonn√©es de l'utilisateur cr√©√©
  v_pseudo := NEW.raw_user_meta_data->>'pseudo';
  v_phone := NEW.raw_user_meta_data->>'phone';
  v_expo_push_token := NEW.raw_user_meta_data->>'expo_push_token';

  -- VALIDATION : Si pas de pseudo, ne pas cr√©er le profil
  IF v_pseudo IS NULL OR TRIM(v_pseudo) = '' THEN
    RAISE WARNING 'Pas de pseudo dans les m√©tadonn√©es pour l''utilisateur %, profil non cr√©√©', NEW.id;
    RETURN NEW;
  END IF;

  -- S√âCURIT√â : V√©rifier si le pseudo est d√©j√† utilis√©
  IF EXISTS (
    SELECT 1 FROM user_profiles 
    WHERE pseudo = TRIM(v_pseudo)
    AND id != NEW.id
  ) THEN
    RAISE EXCEPTION 'Pseudo "%" d√©j√† utilis√©. Veuillez en choisir un autre.', TRIM(v_pseudo)
      USING ERRCODE = '23505', 
            HINT = 'unique_pseudo';
  END IF;

  -- CR√âATION : Cette insertion se fait AVANT l'envoi de l'email de confirmation
  INSERT INTO public.user_profiles (id, pseudo, phone, expo_push_token)
  VALUES (
    NEW.id,
    TRIM(v_pseudo),
    NULLIF(TRIM(v_phone), '')::TEXT,
    NULLIF(TRIM(v_expo_push_token), '')::TEXT
  )
  ON CONFLICT (id) DO NOTHING;

  RETURN NEW;
END;
$$;

-- Le d√©clencheur qui active la fonction √† chaque inscription
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW 
  EXECUTE FUNCTION public.handle_new_user();

-- ============================================================
-- üîí 3. S√âCURIT√â (Rappel des politiques RLS)
-- ============================================================

ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON user_profiles;
DROP POLICY IF EXISTS "Users can read public profiles" ON user_profiles;
CREATE POLICY "Users can read public profiles" 
ON user_profiles FOR SELECT 
USING (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Users can read their own profile" ON user_profiles;
CREATE POLICY "Users can read their own profile" 
ON user_profiles FOR SELECT 
USING (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile" ON user_profiles;
CREATE POLICY "Users can update their own profile" 
ON user_profiles FOR UPDATE 
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

================================================================================
4. CONFIGURATION SUPABASE
================================================================================

DANS LE DASHBOARD SUPABASE:

1. Authentication ‚Üí Settings ‚Üí Email Auth
   ‚úÖ Activer "Enable email confirmations"
   ‚úÖ Activer "Secure email change" (recommand√©)

2. Authentication ‚Üí URL Configuration
   Site URL: proutapp://
   Redirect URLs:
     proutapp://confirm-email
     proutapp://reset-password

3. Authentication ‚Üí Email Templates ‚Üí Confirm signup
   Template personnalis√© avec {{ .ConfirmationURL }}

================================================================================
5. ORDRE D'EX√âCUTION
================================================================================

1. Ex√©cuter le script SQL: supabase_trigger_create_profile_CORRIGE.sql
2. Configurer les URLs de redirection dans Supabase Dashboard
3. Copier les fichiers TypeScript dans les fichiers correspondants
4. Tester le flux complet:
   - Inscription ‚Üí Email envoy√© ‚Üí Clic sur le lien ‚Üí Confirmation ‚Üí Connexion

================================================================================
FIN DU DOCUMENT
================================================================================





